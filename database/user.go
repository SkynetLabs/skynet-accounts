package database

import (
	"context"
	"crypto/subtle"
	"fmt"
	"net/mail"
	"sync"
	"time"

	"github.com/SkynetLabs/skynet-accounts/build"
	"github.com/SkynetLabs/skynet-accounts/hash"
	"github.com/SkynetLabs/skynet-accounts/lib"
	"github.com/SkynetLabs/skynet-accounts/skynet"
	"gitlab.com/NebulousLabs/errors"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"go.mongodb.org/mongo-driver/mongo/readpref"
)

const (
	// TierAnonymous reserved
	TierAnonymous = iota
	// TierFree free
	TierFree
	// TierPremium5 5
	TierPremium5
	// TierPremium20 20
	TierPremium20
	// TierPremium80 80
	TierPremium80
	// TierMaxReserved is a guard value that helps us validate tier values.
	TierMaxReserved

	// filesAllowedPerTiB defines a limit of number of uploaded files we impose
	// on users. While we define it per TiB, we impose it based on their entire
	// quota, so an Extreme user will be able to upload up to 400_000 files
	// before being hit with a speed limit.
	filesAllowedPerTiB = 25_000

	// mbpsToBytesPerSecond is a multiplier to get from mebibits per second to
	// bytes per second.
	mbpsToBytesPerSecond = 1024 * 1024 / 8
)

var (
	// AnonUser is a helper struct that we can use when we don't have a relevant
	// user, e.g. when an upload is made by an anonymous user.
	AnonUser = User{}
	// True is a helper for when we need to pass a *bool to MongoDB.
	True = true
	// False is a helper for when we need to pass a *bool to MongoDB.
	False = false
	// UserLimits defines the speed limits for each tier.
	// RegistryDelay delay is in ms.
	UserLimits = map[int]TierLimits{
		TierAnonymous: {
			TierName:        "anonymous",
			UploadBandwidth: 5 * mbpsToBytesPerSecond,
			// TODO: temporarily lowered the download bandwidth on the anon tier
			// from 20mbps to 5mpbs
			DownloadBandwidth: 5 * mbpsToBytesPerSecond,
			MaxUploadSize:     1 * skynet.GiB,
			MaxNumberUploads:  0,
			RegistryDelay:     250,
			Storage:           0,
		},
		TierFree: {
			TierName:          "free",
			UploadBandwidth:   10 * mbpsToBytesPerSecond,
			DownloadBandwidth: 40 * mbpsToBytesPerSecond,
			MaxUploadSize:     100 * skynet.GiB,
			MaxNumberUploads:  0.1 * filesAllowedPerTiB,
			RegistryDelay:     125,
			Storage:           100 * skynet.GiB,
		},
		TierPremium5: {
			TierName:          "plus",
			UploadBandwidth:   20 * mbpsToBytesPerSecond,
			DownloadBandwidth: 80 * mbpsToBytesPerSecond,
			MaxUploadSize:     1 * skynet.TiB,
			MaxNumberUploads:  1 * filesAllowedPerTiB,
			RegistryDelay:     0,
			Storage:           1 * skynet.TiB,
		},
		TierPremium20: {
			TierName:          "pro",
			UploadBandwidth:   40 * mbpsToBytesPerSecond,
			DownloadBandwidth: 160 * mbpsToBytesPerSecond,
			MaxUploadSize:     4 * skynet.TiB,
			MaxNumberUploads:  4 * filesAllowedPerTiB,
			RegistryDelay:     0,
			Storage:           4 * skynet.TiB,
		},
		TierPremium80: {
			TierName:          "extreme",
			UploadBandwidth:   80 * mbpsToBytesPerSecond,
			DownloadBandwidth: 320 * mbpsToBytesPerSecond,
			MaxUploadSize:     10 * skynet.TiB,
			MaxNumberUploads:  20 * filesAllowedPerTiB,
			RegistryDelay:     0,
			Storage:           20 * skynet.TiB,
		},
	}

	// ErrInvalidToken is returned when the token is found to be invalid for any
	// reason, including expiration.
	ErrInvalidToken = errors.New("invalid token")
)

type (
	// User represents a Skynet user.
	User struct {
		// ID is auto-generated by Mongo on insert. We will usually use it in
		// its ID.Hex() form.
		ID                               primitive.ObjectID `bson:"_id,omitempty" json:"-"`
		Email                            string             `bson:"email" json:"email"`
		EmailConfirmationToken           string             `bson:"email_confirmation_token,omitempty" json:"-"`
		EmailConfirmationTokenExpiration time.Time          `bson:"email_confirmation_token_expiration,omitempty" json:"-"`
		PasswordHash                     string             `bson:"password_hash" json:"-"`
		RecoveryToken                    string             `bson:"recovery_token,omitempty" json:"-"`
		Sub                              string             `bson:"sub" json:"sub"`
		Tier                             int                `bson:"tier" json:"tier"`
		CreatedAt                        time.Time          `bson:"created_at" json:"createdAt"`
		MigratedAt                       time.Time          `bson:"migrated_at" json:"migratedAt"`
		SubscribedUntil                  time.Time          `bson:"subscribed_until" json:"subscribedUntil"`
		SubscriptionStatus               string             `bson:"subscription_status" json:"subscriptionStatus"`
		SubscriptionCancelAt             time.Time          `bson:"subscription_cancel_at" json:"subscriptionCancelAt"`
		SubscriptionCancelAtPeriodEnd    bool               `bson:"subscription_cancel_at_period_end" json:"subscriptionCancelAtPeriodEnd"`
		StripeID                         string             `bson:"stripe_id" json:"stripeCustomerId"`
		QuotaExceeded                    bool               `bson:"quota_exceeded" json:"quotaExceeded"`
		PubKeys                          []PubKey           `bson:"pub_keys" json:"-"`
	}
	// UserStats contains statistical information about the user.
	UserStats struct {
		RawStorageUsed     int64 `json:"rawStorageUsed"`
		NumRegReads        int64 `json:"numRegReads"`
		NumRegWrites       int64 `json:"numRegWrites"`
		NumUploads         int   `json:"numUploads"`
		NumDownloads       int   `json:"numDownloads"`
		TotalUploadsSize   int64 `json:"totalUploadsSize"`
		TotalDownloadsSize int64 `json:"totalDownloadsSize"`
		BandwidthUploads   int64 `json:"bwUploads"`
		BandwidthDownloads int64 `json:"bwDownloads"`
		BandwidthRegReads  int64 `json:"bwRegReads"`
		BandwidthRegWrites int64 `json:"bwRegWrites"`
	}
	// TierLimits defines the speed limits imposed on the user based on their
	// tier.
	TierLimits struct {
		TierName          string `json:"tierName"`
		UploadBandwidth   int    `json:"upload"`        // bytes per second
		DownloadBandwidth int    `json:"download"`      // bytes per second
		MaxUploadSize     int64  `json:"maxUploadSize"` // the max size of a single upload in bytes
		MaxNumberUploads  int    `json:"-"`
		RegistryDelay     int    `json:"registry"` // ms delay
		Storage           int64  `json:"-"`
	}
)

// UserByEmail returns the user with the given username.
func (db *DB) UserByEmail(ctx context.Context, email string) (*User, error) {
	users, err := db.managedUsersByField(ctx, "email", email)
	if err != nil {
		return nil, err
	}
	return users[0], nil
}

// UserByID finds a user by their ID.
func (db *DB) UserByID(ctx context.Context, id primitive.ObjectID) (*User, error) {
	filter := bson.D{{"_id", id}}
	c, err := db.staticUsers.Find(ctx, filter)
	if err != nil {
		return nil, errors.AddContext(err, "failed to Find")
	}
	defer func() {
		if errDef := c.Close(ctx); errDef != nil {
			db.staticLogger.Debugln("Error on closing DB cursor.", errDef)
		}
	}()
	// Get the first result.
	if ok := c.Next(ctx); !ok {
		return nil, ErrUserNotFound
	}
	// Ensure there are no more results.
	if ok := c.Next(ctx); ok {
		build.Critical("more than one user found for id", id)
	}
	var u User
	err = c.Decode(&u)
	if err != nil {
		return nil, errors.AddContext(err, "failed to parse value from DB")
	}
	return &u, nil
}

// UserByPubKey returns the user with the given pubkey.
func (db *DB) UserByPubKey(ctx context.Context, pk PubKey) (*User, error) {
	sr := db.staticUsers.FindOne(ctx, bson.M{"pub_keys": pk})
	var u User
	err := sr.Decode(&u)
	if err != nil {
		return nil, ErrUserNotFound
	}
	return &u, nil
}

// UserByRecoveryToken returns the user with the given recovery token.
func (db *DB) UserByRecoveryToken(ctx context.Context, token string) (*User, error) {
	users, err := db.managedUsersByField(ctx, "recovery_token", token)
	if err != nil {
		return nil, err
	}
	return users[0], nil
}

// UserByStripeID finds a user by their Stripe customer id.
func (db *DB) UserByStripeID(ctx context.Context, id string) (*User, error) {
	filter := bson.D{{"stripe_id", id}}
	c, err := db.staticUsers.Find(ctx, filter)
	if err != nil {
		return nil, errors.AddContext(err, "failed to Find")
	}
	defer func() {
		if errDef := c.Close(ctx); errDef != nil {
			db.staticLogger.Debugln("Error on closing DB cursor.", errDef)
		}
	}()
	// Get the first result.
	if ok := c.Next(ctx); !ok {
		return nil, ErrUserNotFound
	}
	// Ensure there are no more results.
	if ok := c.Next(ctx); ok {
		build.Critical(fmt.Sprintf("more than one user found for stripe customer id '%s'", id))
	}
	var u User
	err = c.Decode(&u)
	if err != nil {
		return nil, errors.AddContext(err, "failed to parse value from DB")
	}
	return &u, nil
}

// UserBySub returns the user with the given sub.
func (db *DB) UserBySub(ctx context.Context, sub string) (*User, error) {
	return db.managedUserBySub(ctx, sub)
}

// UserConfirmEmail confirms that the email to which the passed confirmation
// token belongs actually belongs to its user.
func (db *DB) UserConfirmEmail(ctx context.Context, token string) (*User, error) {
	if token == "" {
		return nil, errors.AddContext(ErrInvalidToken, "token cannot be empty")
	}
	users, err := db.managedUsersByField(ctx, "email_confirmation_token", token)
	if err != nil {
		return nil, errors.AddContext(err, "failed to read users from DB")
	}
	if len(users) == 0 {
		return nil, errors.AddContext(ErrInvalidToken, "no user has this token")
	}
	if len(users) > 1 {
		build.Critical("multiple users found for the same confirmation token", token)
		return nil, errors.AddContext(ErrInvalidToken, "please request a new token")
	}
	u := users[0]
	// Check if the token has expired.
	if u.EmailConfirmationTokenExpiration.Before(time.Now().UTC()) {
		return nil, errors.AddContext(ErrInvalidToken, "token expired")
	}
	u.EmailConfirmationToken = ""
	err = db.UserSave(ctx, u)
	if err != nil {
		return nil, errors.AddContext(err, "failed to update user")
	}
	return u, nil
}

// UserCreate creates a new user in the DB.
//
// The `sub` field is optional.
//
// The new user is created as "unconfirmed" and a confirmation email is sent to
// the address they provided.
func (db *DB) UserCreate(ctx context.Context, emailAddr, pass, sub string, tier int) (*User, error) {
	// Ensure the email is valid if it's passed. We allow empty emails.
	if emailAddr != "" {
		addr, err := mail.ParseAddress(emailAddr)
		if err != nil {
			return nil, errors.AddContext(err, "invalid email address")
		}
		emailAddr = addr.Address
	}
	if sub == "" {
		return nil, errors.New("empty sub is not allowed")
	}

	// Check for an existing user with this email.
	_, err := db.UserByEmail(ctx, emailAddr)
	if err != nil && !errors.Contains(err, ErrUserNotFound) {
		return nil, errors.AddContext(err, "failed to query DB")
	}
	if !errors.Contains(err, ErrUserNotFound) {
		return nil, ErrUserAlreadyExists
	}
	// Check for an existing user with this sub.
	_, err = db.managedUserBySub(ctx, sub)
	if err != nil && !errors.Contains(err, ErrUserNotFound) {
		return nil, errors.AddContext(err, "failed to query DB")
	}
	if !errors.Contains(err, ErrUserNotFound) {
		return nil, ErrUserAlreadyExists
	}
	// Generate a password hash, if a password is provided. A password might not
	// be provided if the user is registered from MySky with a pubkey.
	var passHash []byte
	if pass != "" {
		passHash, err = hash.Generate(pass)
		if err != nil {
			return nil, errors.AddContext(ErrGeneralInternalFailure, "failed to hash password")
		}
	}
	emailConfToken, err := lib.GenerateUUID()
	if err != nil {
		return nil, errors.AddContext(err, "failed to generate an email confirmation token")
	}
	u := &User{
		ID:                               primitive.ObjectID{},
		Email:                            emailAddr,
		EmailConfirmationToken:           emailConfToken,
		EmailConfirmationTokenExpiration: time.Now().UTC().Add(EmailConfirmationTokenTTL).Truncate(time.Millisecond),
		PasswordHash:                     string(passHash),
		Sub:                              sub,
		Tier:                             tier,
	}
	// TODO This part can race and create multiple accounts with the same email, unless we add DB-level uniqueness restriction.
	// Insert the user.
	fields, err := bson.Marshal(u)
	if err != nil {
		return nil, err
	}
	ir, err := db.staticUsers.InsertOne(ctx, fields)
	if err != nil {
		return nil, errors.AddContext(err, "failed to Insert")
	}
	u.ID = ir.InsertedID.(primitive.ObjectID)
	return u, nil
}

// UserCreateEmailConfirmation creates a new email confirmation record for this
// user.
func (db *DB) UserCreateEmailConfirmation(ctx context.Context, uID primitive.ObjectID) (string, error) {
	exp := time.Now().UTC().Add(EmailConfirmationTokenTTL).Truncate(time.Millisecond)
	tk, err := lib.GenerateUUID()
	if err != nil {
		return "", err
	}
	filter := bson.M{"_id": uID}
	update := bson.M{
		"$set": bson.M{
			"email_confirmation_token":            tk,
			"email_confirmation_token_expiration": exp,
		},
	}
	opts := options.Update().SetUpsert(false)
	_, err = db.staticUsers.UpdateOne(ctx, filter, update, opts)
	if err != nil {
		return "", err
	}
	return tk, nil
}

// UserCreatePK creates a new user with a pubkey in the DB.
//
// The `pass` and `sub` fields are optional.
//
// The new user is created as "unconfirmed" and a confirmation email is sent to
// the address they provided.
func (db *DB) UserCreatePK(ctx context.Context, emailAddr, pass, sub string, pk PubKey, tier int) (*User, error) {
	// Validate the email.
	parsed, err := mail.ParseAddress(emailAddr)
	if err != nil || parsed.Address != emailAddr {
		return nil, errors.AddContext(err, "invalid email address")
	}
	// Check for an existing user with this email.
	users, err := db.managedUsersByField(ctx, "email", emailAddr)
	if err != nil && !errors.Contains(err, ErrUserNotFound) {
		return nil, errors.AddContext(err, "failed to query DB")
	}
	if len(users) > 0 {
		return nil, ErrUserAlreadyExists
	}
	if sub == "" {
		sub, err = lib.GenerateUUID()
		if err != nil {
			return nil, errors.AddContext(err, "failed to generate user sub")
		}
	}
	// Check for an existing user with this sub.
	_, err = db.managedUserBySub(ctx, sub)
	if err != nil && !errors.Contains(err, ErrUserNotFound) {
		return nil, errors.AddContext(err, "failed to query DB")
	}
	if !errors.Contains(err, ErrUserNotFound) {
		return nil, ErrUserAlreadyExists
	}
	// Generate a password hash, if a password is provided. A password might not
	// be provided if the user intends to only use pubkey authentication.
	var passHash []byte
	if pass != "" {
		passHash, err = hash.Generate(pass)
		if err != nil {
			return nil, errors.AddContext(ErrGeneralInternalFailure, "failed to hash password")
		}
	}
	emailConfToken, err := lib.GenerateUUID()
	if err != nil {
		return nil, errors.AddContext(err, "failed to generate an email confirmation token")
	}
	u := &User{
		ID:                               primitive.ObjectID{},
		Email:                            emailAddr,
		EmailConfirmationToken:           emailConfToken,
		EmailConfirmationTokenExpiration: time.Now().UTC().Add(EmailConfirmationTokenTTL).Truncate(time.Millisecond),
		PasswordHash:                     string(passHash),
		Sub:                              sub,
		Tier:                             tier,
		PubKeys:                          []PubKey{pk},
	}
	// Insert the user.
	fields, err := bson.Marshal(u)
	if err != nil {
		return nil, err
	}
	ir, err := db.staticUsers.InsertOne(ctx, fields)
	if err != nil {
		return nil, errors.AddContext(err, "failed to Insert")
	}
	u.ID = ir.InsertedID.(primitive.ObjectID)
	return u, nil
}

// UserDelete deletes a user by their ID.
func (db *DB) UserDelete(ctx context.Context, u *User) error {
	if u.ID.IsZero() {
		return errors.AddContext(ErrUserNotFound, "user struct not fully initialised")
	}
	// Delete all data associated with this user.
	filter := bson.D{{"user_id", u.ID}}
	_, err := db.staticDownloads.DeleteMany(ctx, filter)
	if err != nil {
		return errors.AddContext(err, "failed to delete user downloads")
	}
	_, err = db.staticUploads.DeleteMany(ctx, filter)
	if err != nil {
		return errors.AddContext(err, "failed to delete user uploads")
	}
	_, err = db.staticRegistryReads.DeleteMany(ctx, filter)
	if err != nil {
		return errors.AddContext(err, "failed to delete user registry reads")
	}
	_, err = db.staticRegistryWrites.DeleteMany(ctx, filter)
	if err != nil {
		return errors.AddContext(err, "failed to delete user registry writes")
	}
	_, err = db.staticAPIKeys.DeleteMany(ctx, filter)
	if err != nil {
		return errors.AddContext(err, "failed to delete user API keys")
	}
	_, err = db.staticUnconfirmedUserUpdates.DeleteMany(ctx, bson.D{{"sub", u.Sub}})
	if err != nil {
		return errors.AddContext(err, "failed to delete user unconfirmed updates")
	}
	// Delete the actual user.
	filter = bson.D{{"_id", u.ID}}
	dr, err := db.staticUsers.DeleteOne(ctx, filter)
	if err != nil {
		return errors.AddContext(err, "failed to Delete")
	}
	if dr.DeletedCount == 0 {
		return ErrUserNotFound
	}
	return nil
}

// UserSave saves the user to the DB.
func (db *DB) UserSave(ctx context.Context, u *User) error {
	filter := bson.M{"_id": u.ID}
	opts := options.Replace().SetUpsert(true)
	_, err := db.staticUsers.ReplaceOne(ctx, filter, u, opts)
	if err != nil {
		return errors.AddContext(err, "failed to update")
	}
	return nil
}

// UserPubKeyAdd adds a new PubKey to the given user's set.
func (db *DB) UserPubKeyAdd(ctx context.Context, u User, pk PubKey) (err error) {
	filter := bson.M{"_id": u.ID}
	// This update is so complicated because we can't use mutation operations
	// like $push, $addToSet and so on if the target field is null. That's why
	// here we check if the field is an array and then merge the key in. If the
	// field is not an array (i.e. it's null) we set it to an empty array before
	// performing the merge.
	update := bson.A{
		bson.M{
			"$set": bson.M{
				"pub_keys": bson.M{
					"$cond": bson.A{
						bson.M{"$eq": bson.A{bson.M{"$type": "$pub_keys"}, "array"}},
						bson.M{"$setUnion": bson.A{"$pub_keys", bson.A{pk}}},
						bson.A{pk},
					}},
			},
		},
	}
	_, err = db.staticUsers.UpdateOne(ctx, filter, update)
	return err
}

// UserPubKeyRemove removes a PubKey from the given user's set.
func (db *DB) UserPubKeyRemove(ctx context.Context, u User, pk PubKey) error {
	filter := bson.M{
		"_id":      u.ID,
		"pub_keys": bson.M{"$ne": nil},
	}
	update := bson.M{
		"$pull": bson.M{"pub_keys": pk},
	}
	ur, err := db.staticUsers.UpdateOne(ctx, filter, update)
	if err == nil && ur.MatchedCount == 0 {
		err = mongo.ErrNoDocuments
	}
	return err
}

// UserSetStripeID changes the user's stripe id in the DB.
func (db *DB) UserSetStripeID(ctx context.Context, u *User, stripeID string) error {
	filter := bson.M{"_id": u.ID}
	update := bson.M{"$set": bson.M{"stripe_id": stripeID}}
	opts := options.Update().SetUpsert(true)
	_, err := db.staticUsers.UpdateOne(ctx, filter, update, opts)
	if err != nil {
		return errors.AddContext(err, "failed to update")
	}
	return nil
}

// UserSetTier sets the user's tier to the given value.
func (db *DB) UserSetTier(ctx context.Context, u *User, t int) error {
	if t <= TierAnonymous || t >= TierMaxReserved {
		return errors.New("invalid tier value")
	}
	filter := bson.M{"_id": u.ID}
	update := bson.M{"$set": bson.M{"tier": t}}
	opts := options.Update().SetUpsert(true)
	_, err := db.staticUsers.UpdateOne(ctx, filter, update, opts)
	if err != nil {
		return errors.AddContext(err, "failed to update")
	}
	u.Tier = t
	return nil
}

// UserStats returns statistical information about the user.
func (db *DB) UserStats(ctx context.Context, user User) (*UserStats, error) {
	return db.userStats(ctx, user)
}

// Ping sends a ping command to verify that the client can connect to the DB and
// specifically to the primary.
func (db *DB) Ping(ctx context.Context) error {
	ctx2, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()
	return db.staticDB.Client().Ping(ctx2, readpref.Primary())
}

// managedUsersByField finds all users that have a given field value.
// The calling method is responsible for the validation of the value.
func (db *DB) managedUsersByField(ctx context.Context, fieldName, fieldValue string) ([]*User, error) {
	filter := bson.M{fieldName: fieldValue}
	c, err := db.staticUsers.Find(ctx, filter)
	if err != nil {
		return nil, errors.AddContext(err, "failed to find user")
	}
	defer func() {
		if errDef := c.Close(ctx); errDef != nil {
			db.staticLogger.Debugln("Error on closing DB cursor.", errDef)
		}
	}()

	var users []*User
	for c.Next(ctx) {
		var u User
		if err = c.Decode(&u); err != nil {
			return nil, errors.AddContext(err, "failed to parse value from DB")
		}
		users = append(users, &u)
	}
	if len(users) == 0 {
		return users, ErrUserNotFound
	}
	return users, nil
}

// managedUserBySub fetches all users that have the given sub. This should
// normally be up to one user.
func (db *DB) managedUserBySub(ctx context.Context, sub string) (*User, error) {
	sr := db.staticUsers.FindOne(ctx, bson.M{"sub": sub})
	if sr.Err() == mongo.ErrNoDocuments {
		return nil, ErrUserNotFound
	}
	if sr.Err() != nil {
		return nil, sr.Err()
	}
	var u User
	err := sr.Decode(&u)
	if err != nil {
		return nil, err
	}
	return &u, nil
}

// userStats reports statistical information about the user.
func (db *DB) userStats(ctx context.Context, user User) (*UserStats, error) {
	stats := UserStats{}
	var errs []error
	var errsMux sync.Mutex
	regErr := func(msg string, e error) {
		db.staticLogger.Infoln(msg, e)
		errsMux.Lock()
		errs = append(errs, e)
		errsMux.Unlock()
	}
	startOfMonth := monthStart(user.SubscribedUntil)

	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		defer wg.Done()
		n, size, rawStorage, bw, err := db.UserUploadStats(ctx, user.ID, startOfMonth)
		if err != nil {
			regErr("Failed to get user's upload bandwidth used:", err)
			return
		}
		stats.NumUploads = n
		stats.TotalUploadsSize = size
		stats.RawStorageUsed = rawStorage
		stats.BandwidthUploads = bw
		db.staticLogger.Tracef("User %s upload bandwidth: %v", user.ID.Hex(), bw)
	}()
	wg.Add(1)
	go func() {
		defer wg.Done()
		n, size, bw, err := db.userDownloadStats(ctx, user.ID, startOfMonth)
		if err != nil {
			regErr("Failed to get user's download bandwidth used:", err)
			return
		}
		stats.NumDownloads = n
		stats.TotalDownloadsSize = size
		stats.BandwidthDownloads = bw
		db.staticLogger.Tracef("User %s download bandwidth: %v", user.ID.Hex(), bw)
	}()
	wg.Add(1)
	go func() {
		defer wg.Done()
		n, bw, err := db.userRegistryWriteStats(ctx, user.ID, startOfMonth)
		if err != nil {
			regErr("Failed to get user's registry write bandwidth used:", err)
			return
		}
		stats.NumRegWrites = n
		stats.BandwidthRegWrites = bw
		db.staticLogger.Tracef("User %s registry write bandwidth: %v", user.ID.Hex(), bw)
	}()
	wg.Add(1)
	go func() {
		defer wg.Done()
		n, bw, err := db.userRegistryReadStats(ctx, user.ID, startOfMonth)
		if err != nil {
			regErr("Failed to get user's registry read bandwidth used:", err)
			return
		}
		stats.NumRegReads = n
		stats.BandwidthRegReads = bw
		db.staticLogger.Tracef("User %s registry read bandwidth: %v", user.ID.Hex(), bw)
	}()

	wg.Wait()
	if len(errs) > 0 {
		return nil, errors.Compose(errs...)
	}
	return &stats, nil
}

// UserUploadStats reports on the user's uploads - count, total size and total
// bandwidth used. It uses the total size of the uploaded skyfiles as basis.
func (db *DB) UserUploadStats(ctx context.Context, id primitive.ObjectID, since time.Time) (count int, totalSize int64, rawStorageUsed int64, totalBandwidth int64, err error) {
	matchStage := bson.D{{"$match", bson.M{"user_id": id}}}
	lookupStage := bson.D{
		{"$lookup", bson.D{
			{"from", "skylinks"},
			{"localField", "skylink_id"},
			{"foreignField", "_id"},
			{"as", "skylink_data"},
		}},
	}
	replaceStage := bson.D{
		{"$replaceRoot", bson.D{
			{"newRoot", bson.D{
				{"$mergeObjects", bson.A{
					bson.D{{"$arrayElemAt", bson.A{"$skylink_data", 0}}}, "$$ROOT"},
				},
			}},
		}},
	}
	// These are the fields we don't need.
	projectStage := bson.D{{"$project", bson.D{
		{"_id", 0},
		{"user_id", 0},
		{"skylink_data", 0},
		{"name", 0},
		{"skylink_id", 0},
	}}}

	pipeline := mongo.Pipeline{matchStage, lookupStage, replaceStage, projectStage}
	c, err := db.staticUploads.Aggregate(ctx, pipeline)
	if err != nil {
		return
	}
	defer func() {
		if errDef := c.Close(ctx); errDef != nil {
			db.staticLogger.Traceln("Error on closing DB cursor.", errDef)
		}
	}()

	// We need this struct, so we can safely decode both int32 and int64.
	result := struct {
		Size      int64     `bson:"size"`
		Skylink   string    `bson:"skylink"`
		Unpinned  bool      `bson:"unpinned"`
		Timestamp time.Time `bson:"timestamp"`
	}{}
	processedSkylinks := make(map[string]bool)
	for c.Next(ctx) {
		if err = c.Decode(&result); err != nil {
			err = errors.AddContext(err, "failed to decode DB data")
			return
		}
		// We first weed out any old uploads that we fetch only in order to
		// calculate the total used storage.
		if result.Timestamp.Before(since) {
			if result.Unpinned || processedSkylinks[result.Skylink] {
				continue
			}
			processedSkylinks[result.Skylink] = true
			totalSize += result.Size
			continue
		}
		// All bandwidth is counted, regardless of unpinned status.
		totalBandwidth += skynet.BandwidthUploadCost(result.Size)
		// Count only uploads that are still pinned towards total count.
		if result.Unpinned {
			continue
		}
		count++
		// Count only unique uploads towards total size and used storage.
		if processedSkylinks[result.Skylink] {
			continue
		}
		processedSkylinks[result.Skylink] = true
		totalSize += result.Size
		rawStorageUsed += skynet.RawStorageUsed(result.Size)
	}
	return count, totalSize, rawStorageUsed, totalBandwidth, nil
}

// userDownloadStats reports on the user's downloads - count, total size and
// total bandwidth used. It uses the actual bandwidth used, as reported by nginx.
func (db *DB) userDownloadStats(ctx context.Context, id primitive.ObjectID, monthStart time.Time) (count int, totalSize int64, totalBandwidth int64, err error) {
	matchStage := bson.D{{"$match", bson.D{
		{"user_id", id},
		{"created_at", bson.D{{"$gt", monthStart}}},
	}}}
	lookupStage := bson.D{
		{"$lookup", bson.D{
			{"from", "skylinks"},
			{"localField", "skylink_id"}, // field in the downloads collection
			{"foreignField", "_id"},      // field in the skylinks collection
			{"as", "fromSkylinks"},
		}},
	}
	replaceStage := bson.D{
		{"$replaceRoot", bson.D{
			{"newRoot", bson.D{
				{"$mergeObjects", bson.A{
					bson.D{{"$arrayElemAt", bson.A{"$fromSkylinks", 0}}}, "$$ROOT"},
				},
			}},
		}},
	}
	// This stage checks if the download has a non-zero `bytes` field and if so,
	// it takes it as the download's size. Otherwise it reports the full
	// skylink's size as download's size.
	projectStage := bson.D{{"$project", bson.D{
		{"size", bson.D{
			{"$cond", bson.A{
				bson.D{{"$gt", bson.A{"$bytes", 0}}}, // if
				"$bytes",                             // then
				"$size",                              // else
			}},
		}},
	}}}

	pipeline := mongo.Pipeline{matchStage, lookupStage, replaceStage, projectStage}
	c, err := db.staticDownloads.Aggregate(ctx, pipeline)
	if err != nil {
		err = errors.AddContext(err, "DB query failed")
		return
	}
	defer func() {
		if errDef := c.Close(ctx); errDef != nil {
			db.staticLogger.Traceln("Error on closing DB cursor.", errDef)
		}
	}()

	// We need this struct, so we can safely decode both int32 and int64.
	result := struct {
		Size int64 `bson:"size"`
	}{}
	for c.Next(ctx) {
		if err = c.Decode(&result); err != nil {
			err = errors.AddContext(err, "failed to decode DB data")
			return
		}
		count++
		totalSize += result.Size
		totalBandwidth += skynet.BandwidthDownloadCost(result.Size)
	}
	return count, totalSize, totalBandwidth, nil
}

// userRegistryWriteStats reports the number of registry writes by the user and
// the bandwidth used.
func (db *DB) userRegistryWriteStats(ctx context.Context, userID primitive.ObjectID, monthStart time.Time) (int64, int64, error) {
	matchStage := bson.D{{"$match", bson.D{
		{"user_id", userID},
		{"timestamp", bson.D{{"$gt", monthStart}}},
	}}}
	writes, err := db.count(ctx, db.staticRegistryWrites, matchStage)
	if err != nil {
		return 0, 0, errors.AddContext(err, "failed to fetch registry write bandwidth")
	}
	return writes, writes * skynet.CostBandwidthRegistryWrite, nil
}

// userRegistryReadsStats reports the number of registry reads by the user and
// the bandwidth used.
func (db *DB) userRegistryReadStats(ctx context.Context, userID primitive.ObjectID, monthStart time.Time) (int64, int64, error) {
	matchStage := bson.D{{"$match", bson.D{
		{"user_id", userID},
		{"timestamp", bson.D{{"$gt", monthStart}}},
	}}}
	reads, err := db.count(ctx, db.staticRegistryReads, matchStage)
	if err != nil {
		return 0, 0, errors.AddContext(err, "failed to fetch registry read bandwidth")
	}
	return reads, reads * skynet.CostBandwidthRegistryRead, nil
}

// HasKey checks if the given pubkey is among the pubkeys registered for the
// user.
func (u User) HasKey(pk PubKey) bool {
	for _, upk := range u.PubKeys {
		if subtle.ConstantTimeCompare(upk, pk) == 1 {
			return true
		}
	}
	return false
}

// monthStart returns the start of the user's subscription month.
// Users get their bandwidth quota reset at the start of the month.
//
// This function follows the behaviour of Stripe:
// If a month doesn’t have the anchor day, the subscription will be billed on
// the last day of the month. For example, a subscription starting on 31 January
// bills on 28 February (or 29 February in a leap year), then 31 March, 30
// April, and so on.
//
// See: https://stripe.com/docs/billing/subscriptions/billing-cycle
//
// NOTE: This function ignores the time (hour and minutes) of the sub expiration
// - all quotas reset at midnight UTC.
func monthStart(subscribedUntil time.Time) time.Time {
	return monthStartWithTime(subscribedUntil, time.Now().UTC())
}

// monthStartWithTime returns the start of the user's subscription month in
// relation to the given `now` value. This function exists only for testing
// purposes and implements the desired behaviour of monthStart.
func monthStartWithTime(subscribedUntil time.Time, current time.Time) time.Time {
	// Normalize the day of month. Subs ending on 31st should end on the last
	// day of the month when the month doesn't have 31 days.
	dayOfMonth := normalizeDayOfMonth(current.Month(), subscribedUntil.Day(), current)
	// If we're past the reset day this month, use the current day of the month.
	if current.Day() >= dayOfMonth {
		return time.Date(current.Year(), current.Month(), dayOfMonth, 0, 0, 0, 0, time.UTC)
	}
	// If we haven't reached the reset day this month, use last month's day.
	dayOfMonth = normalizeDayOfMonth(current.Month()-1, subscribedUntil.Day(), current)
	return time.Date(current.Year(), current.Month()-1, dayOfMonth, 0, 0, 0, 0, time.UTC)
}

// normalizeDayOfMonth checks whether the current month has the given day and if
// it doesn't, it returns the last day the current month has.
//
// Example:
// In February normalizeDayOfMonth(31) will return 28 or 29.
func normalizeDayOfMonth(month time.Month, day int, current time.Time) int {
	t := time.Date(current.Year(), month, day, 0, 0, 0, 0, time.UTC)
	if t.Month() > month {
		// This month doesn't have this day. Return the last day of the month.
		t = time.Date(current.Year(), month+1, 0, 0, 0, 0, 0, time.UTC)
	}
	return t.Day()
}
