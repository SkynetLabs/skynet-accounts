package database

import (
	"context"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/NebulousLabs/skynet-accounts/build"

	"gitlab.com/NebulousLabs/errors"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

const (
	// User status tiers.
	TierReserved = iota
	TierFree
	TierPremium5
	TierPremium20
	TierPremium80

	KB = 1024
	MB = 1024 * KB

	// Prices

	PriceBandwidthRegistryWrite = 5 * MB
	PriceBandwidthRegistryRead  = MB

	// PriceBandwidthUploadBase is the baseline bandwidth price for each upload.
	// This is the cost of uploading the base sector.
	PriceBandwidthUploadBase = 40 * MB
	// PriceBandwidthUploadIncrement is the bandwidth price per 40MB beyond
	// the base sector (beyond the first 4MB). Rounded up.
	PriceBandwidthUploadIncrement = 120 * MB
	// PriceBandwidthDownloadBase is the baseline bandwidth price for each Download.
	PriceBandwidthDownloadBase = 200 * KB
	// PriceBandwidthDownloadIncrement is the bandwidth price per 64B. Rounded up.
	PriceBandwidthDownloadIncrement = 64

	// PriceStorageUploadBase is the baseline storage price for each upload.
	// This is the cost of uploading the base sector.
	PriceStorageUploadBase = 4 * MB
	// PriceStorageUploadIncrement is the storage price for each 40MB beyond
	// the base sector (beyond the first 4MB). Rounded up.
	PriceStorageUploadIncrement = 40 * MB
)

type (
	// User represents a Skynet user.
	User struct {
		// ID is a hexadecimal string representation of the MongoDB id assigned
		// to this user object. It is auto-generated by Mongo on insert.
		ID              primitive.ObjectID `bson:"_id,omitempty" json:"-"`
		Sub             string             `bson:"sub" json:"sub"`
		Tier            int                `bson:"tier" json:"tier"`
		StorageUsed     int64              `bson:"storage_used" json:"storageUsed"`
		BandwidthUsed   int64              `bson:"-" json:"bandwidthUsed"`
		SubscribedUntil time.Time          `bson:"subscribed_until" json:"subscribedUntil"`
	}
)

// UserBySub returns the user with the given sub. If `create` is `true` it will
// create the user if it doesn't exist. The sub is the Kratos id of that user.
func (db *DB) UserBySub(ctx context.Context, sub string, create bool) (*User, error) {
	users, err := db.managedUsersByField(ctx, "sub", sub)
	if create && errors.Contains(err, ErrUserNotFound) {
		return db.UserCreate(ctx, sub, TierFree)
	}
	if err != nil {
		return nil, err
	}
	return users[0], nil
}

// UserByID finds a user by their ID.
func (db *DB) UserByID(ctx context.Context, id primitive.ObjectID) (*User, error) {
	filter := bson.D{{"_id", id}}
	c, err := db.staticUsers.Find(ctx, filter)
	if err != nil {
		return nil, errors.AddContext(err, "failed to Find")
	}
	defer func() { _ = c.Close(ctx) }()
	// Get the first result.
	if ok := c.Next(ctx); !ok {
		return nil, ErrUserNotFound
	}
	// Ensure there are no more results.
	if ok := c.Next(ctx); ok {
		build.Critical("more than one user found for id", id)
	}
	var u User
	err = c.Decode(&u)
	if err != nil {
		return nil, errors.AddContext(err, "failed to parse value from DB")
	}
	return &u, nil
}

// UserCreate creates a new user in the DB.
func (db *DB) UserCreate(ctx context.Context, sub string, tier int) (*User, error) {
	// Check for an existing user with this sub.
	users, err := db.managedUsersByField(ctx, "sub", sub)
	if err != nil && !errors.Contains(err, ErrUserNotFound) {
		return nil, errors.AddContext(err, "failed to query DB")
	}
	if len(users) > 0 {
		return nil, ErrUserAlreadyExists
	}
	u := &User{
		ID:   primitive.ObjectID{},
		Sub:  sub,
		Tier: tier,
	}
	// Insert the user.
	fields, err := bson.Marshal(u)
	if err != nil {
		return nil, err
	}
	ir, err := db.staticUsers.InsertOne(ctx, fields)
	if err != nil {
		return nil, errors.AddContext(err, "failed to Insert")
	}
	u.ID = ir.InsertedID.(primitive.ObjectID)
	return u, nil
}

// UserDelete deletes a user by their ID.
func (db *DB) UserDelete(ctx context.Context, u *User) error {
	if u.ID.IsZero() {
		return errors.AddContext(ErrUserNotFound, "user struct not fully initialised")
	}
	filter := bson.D{{"_id", u.ID}}
	dr, err := db.staticUsers.DeleteOne(ctx, filter)
	if err != nil {
		return errors.AddContext(err, "failed to Delete")
	}
	if dr.DeletedCount == 0 {
		return ErrUserNotFound
	}
	return nil
}

// UserUpdate changes the user's data in the DB.
// It never changes the id or sub of the user.
func (db *DB) UserUpdate(ctx context.Context, u *User) error {
	// Update the user.
	filter := bson.M{"_id": u.ID}
	update := bson.M{"$set": bson.M{
		"tier": u.Tier,
	}}
	opts := options.Update().SetUpsert(true)
	_, err := db.staticUsers.UpdateOne(ctx, filter, update, opts)
	if err != nil {
		return errors.AddContext(err, "failed to update")
	}
	return nil
}

// UserUpdateUsedStorage changes the user's used storage respective to the size
// of the upload.
func (db *DB) UserUpdateUsedStorage(ctx context.Context, id primitive.ObjectID, uploadSize int64) error {
	if uploadSize <= 0 {
		return errors.New("invalid upload size, it needs to be positive, got: " + strconv.Itoa(int(uploadSize)))
	}
	storageInc := PriceStorageUploadBase + numChunks(uint64(uploadSize))*PriceStorageUploadIncrement
	filter := bson.M{"_id": id}
	update := bson.M{"$inc": bson.M{
		"storage_used": storageInc,
	}}
	_, err := db.staticUsers.UpdateOne(ctx, filter, update)
	return err
}

// managedUsersByField finds all users that have a given field value.
// The calling method is responsible for the validation of the value.
func (db *DB) managedUsersByField(ctx context.Context, fieldName, fieldValue string) ([]*User, error) {
	// TODO Add filtering on current period and so on. For the moment we'll
	// 	report overall data.

	filter := bson.D{{fieldName, fieldValue}}
	c, err := db.staticUsers.Find(ctx, filter)
	if err != nil {
		return nil, errors.AddContext(err, "failed to find user")
	}
	defer func() { _ = c.Close(ctx) }()

	var users []*User
	var errs []error
	for c.Next(ctx) {
		var u User
		if err = c.Decode(&u); err != nil {
			return nil, errors.AddContext(err, "failed to parse value from DB")
		}
		u.BandwidthUsed, err = db.userBandwidth(ctx, u.ID)
		if err != nil {
			db.staticLogger.Debugf("Failed to fetch bandwidth used for user (%s: %s): %v", fieldName, fieldValue, err)
			errs = append(errs, err)
		}
		users = append(users, &u)
	}
	if len(users) == 0 {
		return users, ErrUserNotFound
	}
	if len(errs) > 0 {
		return nil, errors.Compose(errs...)
	}
	return users, nil
}

// userBandwidth reports the total bandwidth used by the user.
func (db *DB) userBandwidth(ctx context.Context, id primitive.ObjectID) (int64, error) {
	var bandwidthAtomic int64
	var errs []error
	var errsMux sync.Mutex
	regErr := func(msg string, e error) {
		db.staticLogger.Info(msg, e)
		errsMux.Lock()
		errs = append(errs, e)
		errsMux.Unlock()
	}
	monthStart, err := db.monthStart(ctx, id)
	if err != nil {
		return 0, errors.AddContext(err, "failed to calculate the start of month for user")
	}

	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		defer wg.Done()
		bw, err := db.userUploadBandwidth(ctx, id, monthStart)
		if err != nil {
			regErr("Failed to get user's upload bandwidth used:", err)
			return
		}
		db.staticLogger.Tracef("User %s upload bandwidth: %v", id.Hex(), bw)
		atomic.AddInt64(&bandwidthAtomic, bw)
	}()
	wg.Add(1)
	go func() {
		defer wg.Done()
		bw, err := db.userDownloadBandwidth(ctx, id, monthStart)
		if err != nil {
			regErr("Failed to get user's download bandwidth used:", err)
			return
		}
		db.staticLogger.Tracef("User %s download bandwidth: %v", id.Hex(), bw)
		atomic.AddInt64(&bandwidthAtomic, bw)
	}()
	wg.Add(1)
	go func() {
		defer wg.Done()
		bw, err := db.userRegistryWriteBandwidth(ctx, id, monthStart)
		if err != nil {
			regErr("Failed to get user's registry write bandwidth used:", err)
			return
		}
		db.staticLogger.Tracef("User %s registry write bandwidth: %v", id.Hex(), bw)
		atomic.AddInt64(&bandwidthAtomic, bw)
	}()
	wg.Add(1)
	go func() {
		defer wg.Done()
		bw, err := db.userRegistryReadBandwidth(ctx, id, monthStart)
		if err != nil {
			regErr("Failed to get user's registry read bandwidth used:", err)
			return
		}
		db.staticLogger.Tracef("User %s registry read bandwidth: %v", id.Hex(), bw)
		atomic.AddInt64(&bandwidthAtomic, bw)
	}()

	wg.Wait()
	if len(errs) > 0 {
		return 0, errors.Compose(errs...)
	}
	return bandwidthAtomic, nil
}

// userUploadBandwidth reports the upload bandwidth used by the user. It uses
// the total size of the uploaded skyfiles as basis.
func (db *DB) userUploadBandwidth(ctx context.Context, id primitive.ObjectID, monthStart time.Time) (int64, error) {
	matchStage := bson.D{{"$match", bson.D{
		{"user_id", id},
		{"timestamp", bson.D{{"$gt", monthStart}}},
	}}}
	lookupStage := bson.D{
		{"$lookup", bson.D{
			{"from", "skylinks"},
			{"localField", "skylink_id"},
			{"foreignField", "_id"},
			{"as", "skylink_data"},
		}},
	}
	replaceStage := bson.D{
		{"$replaceRoot", bson.D{
			{"newRoot", bson.D{
				{"$mergeObjects", bson.A{
					bson.D{{"$arrayElemAt", bson.A{"$skylink_data", 0}}}, "$$ROOT"},
				},
			}},
		}},
	}
	// These are the fields we don't need.
	projectStage := bson.D{{"$project", bson.D{
		{"_id", 0},
		{"user_id", 0},
		{"skylink", 0},
		{"skylink_data", 0},
		{"name", 0},
		{"skylink_id", 0},
		{"timestamp", 0},
	}}}

	pipeline := mongo.Pipeline{matchStage, lookupStage, replaceStage, projectStage}
	c, err := db.staticUploads.Aggregate(ctx, pipeline)
	if err != nil {
		return 0, err
	}
	defer func() { _ = c.Close(ctx) }()
	var bandwidth int64
	// We need this struct, so we can safely decode both int32 and int64.
	result := struct {
		Size uint64 `bson:"size"`
	}{}
	for c.Next(ctx) {
		if err = c.Decode(&result); err != nil {
			return 0, errors.AddContext(err, "failed to decode DB data")
		}
		bandwidth += PriceBandwidthUploadBase + int64(numChunks(result.Size))*PriceBandwidthUploadIncrement
	}
	return bandwidth, nil
}

// userDownloadBandwidth reports the download bandwidth used by the user. It
// uses the cumulative downloaded amount, noted with each download record. Those
// numbers account for the actual bandwidth used, as reported by nginx.
func (db *DB) userDownloadBandwidth(ctx context.Context, id primitive.ObjectID, monthStart time.Time) (int64, error) {
	matchStage := bson.D{{"$match", bson.D{
		{"user_id", id},
		{"timestamp", bson.D{{"$gt", monthStart}}},
	}}}
	groupStage := bson.D{{"$group", bson.D{
		{"_id", "$user_id"},
		{"bandwidth", bson.D{{"$sum", "$bytes"}}},
	}}}

	// TODO Add an aggregation here that joins on the skylinks collection and
	// 	if the bytes are 0 chooses skylink size, similar to generateDownloadsPipeline.
	/*
			db.downloads.aggregate([
		    {$match: {"user_id": ObjectId("601be02c70d926e455896a6a")}},
		    {$lookup: {
		        from: "skylinks",
		        localField: "skylink_id",
		        foreignField: "_id",
		        as: "skylink_data",
		    }},
		    { $replaceRoot: { newRoot: { $mergeObjects: [ { $arrayElemAt: [ "$skylink_data", 0 ] }, "$$ROOT" ] } } },
		    { $project: {
		        _id: 0,
		        skylink: 1, name: 1, user_id: 1, skylink_id: 1, timestamp: 1,
		        size: { "$cond": [
		            {"$gt": ['$bytes', 0]},
		            '$bytes',
		            '$size'
		            ] }
		    }}
	*/

	pipeline := mongo.Pipeline{matchStage, groupStage}
	c, err := db.staticDownloads.Aggregate(ctx, pipeline)
	if err != nil {
		return 0, errors.AddContext(err, "DB query failed")
	}
	defer func() { _ = c.Close(ctx) }()
	if ok := c.Next(ctx); !ok {
		// No results found. This is expected.
		return 0, nil
	}
	// We need this struct, so we can safely decode both int32 and int64.
	result := struct {
		Bandwidth int64 `bson:"bandwidth"`
	}{}
	if err = c.Decode(&result); err != nil {
		return 0, errors.AddContext(err, "failed to decode DB data")
	}
	return result.Bandwidth, nil
}

// userRegistryWriteBandwidth reports the bandwidth used by the user's registry
// writes.
func (db *DB) userRegistryWriteBandwidth(ctx context.Context, userId primitive.ObjectID, monthStart time.Time) (int64, error) {
	matchStage := bson.D{{"$match", bson.D{
		{"user_id", userId},
		{"timestamp", bson.D{{"$gt", monthStart}}},
	}}}
	writes, err := count(ctx, db.staticRegistryWrites, matchStage)
	if err != nil {
		return 0, errors.AddContext(err, "failed to fetch registry write bandwidth")
	}
	return writes * PriceBandwidthRegistryWrite, nil
}

// userRegistryReadBandwidth reports the bandwidth used by the user's registry
// reads.
func (db *DB) userRegistryReadBandwidth(ctx context.Context, userId primitive.ObjectID, monthStart time.Time) (int64, error) {
	matchStage := bson.D{{"$match", bson.D{
		{"user_id", userId},
		{"timestamp", bson.D{{"$gt", monthStart}}},
	}}}
	reads, err := count(ctx, db.staticRegistryReads, matchStage)
	if err != nil {
		return 0, errors.AddContext(err, "failed to fetch registry read bandwidth")
	}
	return reads * PriceBandwidthRegistryRead, nil
}

// monthStart returns the start of the user's subscription month. Users get
// their bandwidth quota reset at the start of the month.
func (db *DB) monthStart(ctx context.Context, userId primitive.ObjectID) (time.Time, error) {
	user, err := db.UserByID(ctx, userId)
	if err != nil {
		return time.Time{}, errors.AddContext(err, "failed to fetch user")
	}
	now := time.Now().UTC()
	daysDelta := now.Day() - user.SubscribedUntil.Day()
	d := now.AddDate(0, 0, -1*daysDelta)
	if daysDelta <= 0 {
		d = now.AddDate(0, -1, daysDelta)
	}
	monthStart := time.Date(d.Year(), d.Month(), d.Day(), 0, 0, 0, 0, time.UTC)
	return monthStart, nil
}

// numChunks returns the number of 40MB chunks a file of this size uses, beyond
// the 4MB in the base sector.
func numChunks(size uint64) uint64 {
	if size <= 4*MB {
		return 0
	}
	chunksBeyondBase := (size - 4*MB) / (40 * MB)
	if (size-4*MB)%(40*MB) > 0 {
		chunksBeyondBase++
	}
	return chunksBeyondBase
}
